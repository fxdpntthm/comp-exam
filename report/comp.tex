\newif\ifcomments\commentstrue

\RequirePackage[svgnames,dvipsnames,prologue,x11names]{xcolor}

\documentclass[manuscript,screen,nonacm]{acmart}

\usepackage{comp}

\title{Practical Functional Programming in System F and extensions}
% \subtitle{Extensions to System F}

\author{Apoorv Ingle}
%\orcid{0000-0002-7399-9762}
\affiliation{%
  \institution{University of Iowa}
  \department{Department of Computer Science}
  \streetaddress{McLean Hall}
  \city{Iowa City}
  \state{Iowa}
  \country{USA}}
% \keywords{typeclass, type family}

\begin{document}
\begin{abstract}
The following report is a juxtaposition of the series of extensions to \SF and its theoretical developments. We begin with a brief description of \SF in a type intrinsic setting and give some context about its importance and its meta-theoretic properties. We then move on to describe the first extension to \SF, \SFC, that enriches the calculus with explicit type equalities. The repercussions of this extension is extensive as it gives a way to perform type level computation. \SFC is then extended to \SFP with an expressive kind---the type of types---system that enables an even more expressive type level computation. Finally, we discuss \SFK which enables expressing kind level equalities along with existing type level equalities in the system by squashing the distinction between types and kinds.

While the theoretical aspects of each of these systems are important, we want to expose this power to the programmers---the end users of these systems---, in a safe and a friendly fashion. We describe a framework \HMX that parameterizes over the feature domain X such that for each of the systems described above we get a type inference algorithm for free, and we do not have to redesign and reimplement them.

We conclude the report with some open problems in the area.  
\end{abstract}
\maketitle

% \pagestyle{plain}

\newcommand\STLC{\textbf{STLC}\xspace}
\newcommand\cy[1]{[\citeyear{#1}]}
\section{\SF}
\subsection{History and Inception}
Simply typed lambda calculus (\STLC) was devised by \citet{church_formulation_1940} to avoid the paradoxes that are possible in untyped lambda calculus. \STLC, in its bare form has three constructs: Variables, lambda abstractions and applications. Lambda abstractions and applications are devices to model functions and function calls respectively. Simple types, however, makes the system too restrictive. Consider an identity function that takes an argument of some base type, say $i$, and returns it unchanged.
$$
id_\alpha = \Lam {x\co \alpha} x
$$
In \STLC, although the function behavior is the same at each base type, there would be a different identity function for each such base type. Further, if a new base type is introduced in the system, we would have to define a new identity function for it. Functions, such as identity, are said to be parametrically polymorphic\cite{strachey_fundamental_2000} when their behavior does not change depending on the type of the arguments.

To give a better account for such parametric functions, \citet{reynolds_towards_1974} proposed an extension of \STLC which later famously became \SF. Reynolds extension to \STLC is straightforward. It contains two extra syntactic constructs: type abstractions and type applications. This extension is simple enough to express parametric functions. For example, the identity function will be expressed as follows:
$$
id = \TLam \alpha \Lam {x\co\alpha}. x
$$
\begin{figure}[ht]
  \centering
  \begin{syntax}
    \text{Type Vars} &&\alpha,\beta,\gamma \\
    \text{Term Vars} &&x,y          \\
  \end{syntax}
  \begin{syntax}
    \text{Kinds}     &&\kappa       &::= \star \mid \kappa \to \kappa\\
    \text{Types}     &&\tau,\sigma  &::= \alpha \mid T \mid \tau \to \tau \mid \tau\App\tau \mid \syntaxhl{\Forall {\alpha\co\kappa} \tau}\\
    \text{Terms}     &&\Tm,N          &::= x \mid  H \mid \Lam {x\co\tau} M \mid M\App N \mid \syntaxhl{\TLam{\tau\co\kappa} M \mid M\App \tau}\\
  \end{syntax}
  \begin{syntax}
    \text{Typing Context} &&\TEnv &::= \empt \mid \TEnv,x\co\tau \mid \TEnv,\alpha\co\kappa \mid \TEnv,H\co T\\
    \text{Substitutions}  &&\Subst
  \end{syntax}
  \caption{\SF as an extension of \STLC with kinds}
  \label{fig:system-f-syntax}
\end{figure}

\newcommand\KVar{
  \ib{\irule[\trule{k-var}]
    {\alpha\co\kappa \in \TEnv};
    {\Kinding \TEnv \alpha \kappa}}
}

\newcommand\KVarCo{
  \ib{\irule[\trule{co-var}]
    {c \co \sigma\sim\tau \in \TEnv};
    {\Kinding \TEnv c \sigma\sim\tau}}
}


\newcommand\KConst{
  \ib{\irule[\trule{k-const}]
    {T\co\kappa \in \TEnv};
    {\Kinding \TEnv T \kappa}}
}

\newcommand\KTApp{
  \ib{\irule[\trule{k-tapp}]
    {\Kinding \TEnv {\tau_1} {\kappa_1 \to \kappa}}
    {\Kinding \TEnv {\tau_2} {\kappa_1}};
    {\Kinding \TEnv {\tau_1\App \tau_2} \kappa}}
}


\newcommand\TVar{
  \ib{\irule[\trule{var}]
    {x\co\tau \in \TEnv}
    {\Kinding \TEnv \tau \kappa};
    {\Typing \TEnv x \tau}}
}

\newcommand\TConst{
  \ib{\irule[\trule{const}]
    {H\co T \in \TEnv};
    {\Typing \TEnv H T}}
}

\newcommand\TAbs{
  \ib{\irule[\trule{$\I\to$}]
    {\Typing {\TEnv, x\co\tau_1} {\Tm} {\tau_2}};
    {\Typing \TEnv {\Lam x \Tm} {\tau_1 \to \tau_2}}}
}
 
\newcommand\TApp{
  \ib{\irule[\trule{$\E\to$}]
    {\Typing \TEnv {\Tm_1} {\tau_2 \to \tau}}
    {\Typing \TEnv {\Tm_2} {\tau_2}};
    {\Typing \TEnv {\Tm_1\App\Tm_2} {\tau}}}
}

\newcommand\TForallI{
  \ib{\irule[\trule{$\I\forall$}]
    {\Typing {\TEnv,\alpha\co\kappa} \Tm \tau}
    {\alpha \not\in \dom\TEnv};
    {\Typing \TEnv {\TLam {\alpha\co\kappa} \Tm} {\Forall{\alpha\co\kappa}\tau}}
  }
}

\newcommand\TForallE{
  \ib{\irule[\trule{$\E\forall$}]
    {\Typing \TEnv \Tm {\Forall{\alpha\co\kappa}\sigma}}
    {\Kinding \TEnv \tau \kappa}
    {\Subst = \Sub \alpha \tau};
    {\Typing \TEnv {\Tm\App\tau} {\Subst\sigma}}
  }
}

\begin{figure}[ht]
  \begin{gather*}
    \fbox{$\Kinding \KEnv \tau \kappa$}\\
    \KVar \rsp \KConst \rsp \KTApp
  \end{gather*}
  
  \centering
  \begin{gather*}
    \fbox{$\Typing \TEnv \Tm \tau$}\\
    \TVar \rsp \TConst\\
    \TAbs \rsp \TApp\\
    \TForallI \rsp \TForallE
  \end{gather*}

  \caption{Static Semantics of \SF}
  \label{fig:sf-typing}
\end{figure}

\newcommand{\SOPL}{P$_2$\xspace}
This extension from \STLC makes the semantics extremely powerful. \citet{girard_interpretation_1972}, about two years before Reynolds, proved the Representation theorm ($\mathcal{G}$), that says: all total functions on natural numbers in the second order propositional logic (\SOPL) can be expressed in \SF. \citet{reynolds_types_1983} formulated the Abstraction theorem ($\mathcal{R}$) that proves \SF is an embedding of \SOPL and \citet{wadler_girard-reynolds_2001} later showed that the abstraction followed by embedding is an identity transformation.

\begin{figure}[ht]
  \centering
    \begin{tikzpicture}
    \draw (0, 0) circle [x radius=0.5, y radius=1];
    \node [label=above:\SF] (f2) at (0, 2) {};

    \begin{scope}[xshift=3cm]
      \draw (0, 0) circle [x radius=0.7, y radius=1.5];
      \draw[dotted] (0, 0) circle [x radius=0.5, y radius=1];
      \node [label=above:\SOPL] (p2) at (0, 2) {};
    \end{scope}
  \end{tikzpicture}
  \caption{Relationship between \SF and \SOPL}
  \label{fig:sf-p2-relation}
\end{figure}

\section{Features of Typed Functional Programming Languages}

\subsection{From Parametric Polymorphism to Ad-hoc Polymorphism}
In contrast to the term \lstinline{id}, consider the following two terms:
\begin{code}
    t1 :: Int = 1 + 2
    t2 :: Float = 1.1 + 2.3
\end{code}

In the first case we see that the operator \lstinline{+} is applied to two integers, but in the second case it is applied to two floating point numbers. Although the programmer uses the same symbol, the meanings of each of the programs is completely different. One adds two \lstinline{Int} and returns an \lstinline{Int} while the other adds two \lstinline{Float} and returns a \lstinline{Float}. Further, the compiled code for each would also be different. The runtime code would make a call to two different built in constructs. Such kind of function reuse, which is dependent on the context or the type of arguments, is called as ad-hoc polymorphism\cite{strachey_fundamental_2000}. Implicit operator overloading is a general mechanism to impliment ad-hoc polymorphism where the compiler resolves the overloaded operator to the actual operator.

To make implicit overloading practical \citet{wadler_polymorphism_1989} proposed a dictonary passing style by using a mechanism. This technique became the foundation for Haskell\cite{haskell_2010} typeclasses. Kaes\cy{kaes_parametric_1988} had similar ideas related to implimentation aspects of ad-hoc polymorphism before Wadler et al. ML and its varients\cite{milner_definition_1997,leroy_ocaml_2023} takes a more restricted approach and refuses to allow operator overloading by design.

Implicit objects\cite{oliveira_typeclasses_2010} provide a mechanism for users to choose the intended behavior instance if there are multiple available options. This pushes the burden of choosing the right instance on programmer whenever the typechecker cannot figure out the right option or when.

There have been various attempts\cite{jones_modular_1996, dreyer_modular_2007, wehr_ml_2008, white_modular_2014} to enable a happy co-existence of parametric and implicit ad-hoc polymorphism together in a language by encoding typeclasses as modules and vice versa. However, in presense of modularity to support separate code compilation, it becomes impossible to avoid incoherence without cripling the language expressibility.


\subsection{Functional Dependencies and Typeclasses}

\subsection{Algebraic Datatypes and Generalized Algebraic Datatypes}
Algebraic Datatypes (ADT) can be viewed as a composite datatype that is composed with named sums of products. They enhance the expressivity of the language by allowing users to declare their own structures and aid in organizing data. 

\subsection{Intensional vs Extensional}
Intensional: When the type is tied together with its term. This makes typechecking easy but makes terms ``rigid''.
Extensional: The type is loosly tied with the term

\subsection{Treatment of Equalities}
There are two ways of remembering type equalities that the typechecker would have proved or the ones provided by the user: Store them as terms or store them as types. Both of them seem to be equally attractive however they have significant computational differences

Storing them as term makes the type equality coercions explicit in the code, helps type checking. For a proof assistant it would be an attractive feature, but for a programming language it would mean that we carry such
type equality proofs into the compiled language. Dynamic type dispatch is a an important application for being able to carry proofs about type equalities.

Storing them as types has an advantage that we can erase the equality proofs before compiling it to a more efficient runtime representation. After all, type equalities are only really needed by the type checker to prove that nothing will go wrong at runtime. At runtime we don't need it.

\section{Varients of \SF}
\subsection{\SFC}\label{sec:sfc}
Some key points to cover:

Store the equality between types explicitly in the AST during type checking.

New technique: coercion is a type and its kind tells us what types does the coercion equate.

Features that can be directly expressed in \SFC: New types or generative types, associated types, functional dependencies, generalized algebraic datatypes (GADTs).

Brand new feature user defined open type functions.

Makes type rewriting complicated. But makes the type system more expressive by making it extensible.
Proving type soundness is a bit more involved now.

why don't we have a rule that says: if $\sigma_1 \sim \sigma_2$ then 

\begin{figure}[ht]
  \centering
  \begin{syntax}
    \text{Type Vars} &\alpha,\beta,\gamma \\
    \text{Term Vars} &x,y          \\
    \text{Coercion Constants} &c 
  \end{syntax}
  \begin{syntax}
    \text{Kinds}     &&\kappa       &::= ... \mid \sigma \sim \tau\\
    \text{Types}     &&\tau,\sigma  &::= ... \mid F_n\\
    \text{Coercions} && \Co         &::= \refl\tau \mid \sym\Co \mid \comp\nu\Co \mid \Co\At\tau \mid \left \Co \mid \right \Co \\
      \text{Terms}     &&M,N  &::= ...\mid \Cast \Tm \Co\\
  \end{syntax}
  \caption{Terms and Types of \SFC as an extension of \SF}
  \label{fig:system-fc-syntax}
\end{figure}


\newcommand\TCast{
  \ib{\irule[\trule{cast}]
    {\Typing \TEnv {\Tm} {\tau}}
    {\Typing \TEnv \gamma {\tau \sim \sigma}};
    {\KTyping \TEnv {\Cast \Tm \gamma} {\sigma}}
  }
}

\newcommand\KReflCo{
  \ib{\irule[\trule{co-refl}]
    {\Typing \TEnv \tau \kappa};
    {\Typing \TEnv {\refl \tau} {\tau \sim \tau}}
  }
}

\newcommand\KSymCo{
  \ib{\irule[\trule{co-sym}]
    {\Typing \TEnv \gamma {\tau \sim \sigma}};
    {\Typing \TEnv {\sym \gamma} {\sigma \sim \tau}}
  }
}

\newcommand\KTransCo{
  \ib{\irule[\trule{co-trans}]
    {\Typing\TEnv {\gamma_1} {\tau \sim \tau_2}}
    {\Typing\TEnv {\gamma_2} {\tau_2 \sim \sigma}};
    {\Typing\TEnv {\comp \gamma_1 \gamma_2} {\tau \sim \sigma}}
  }
}

\newcommand\KInstCo{
  \ib{\irule[\trule{co-$\E\forall$}]
    {\Typing\TEnv \gamma {\Forall\alpha\tau_1 \sim \Forall\beta\tau_2}}
    {\Subst_1 = \Sub\alpha\sigma}{\Subst_2 = \Sub\beta\sigma};
    {\Typing\TEnv {\gamma\At\sigma} {\Subst_1\tau_1 \sim \Subst_2\tau_2}}
  }
}

\newcommand\KForallCo{
  \ib{\irule[\trule{co-$\I\forall$}]
    {\Typing {\TEnv,\alpha\co\kappa} \gamma {\tau_1 \sim \tau_2}}{\alpha \# \TEnv};
    {\Typing \TEnv {\Forall {\alpha\co\kappa} \gamma} {\Forall {\alpha\co\kappa}\tau_1 \sim \Forall {\alpha\co\kappa}\tau_2}}
  }
}


\newcommand\KAppCo{
  \ib{\irule[\trule{co-left}]
    {\Typing \TEnv {\gamma_1} {\tau_1 \sim \tau_2}}
    {\Typing \TEnv {\gamma_2} {\sigma_1 \sim \sigma_2}}
    {\Typing \TEnv {\tau_i \sigma_i} \kappa};
    {\Typing \TEnv {\gamma_1 \gamma_2} {\tau_1 \sigma_1 \sim \tau_2 \sigma_2}}
  }
}

\newcommand\KLeftCo{
  \ib{\irule[\trule{co-left}]
    {\Typing \TEnv {\gamma} {\tau_1 \App \sigma_1 \sim \tau_2 \App \sigma_2}};
    {\Typing \TEnv {\left \gamma} {\tau_1 \sim \tau_2}}
  }
}

\newcommand\KRightCo{
  \ib{\irule[\trule{co-right}]
    {\Typing \TEnv {\gamma} {\tau_1 \App \sigma_1 \sim \tau_2 \App \sigma_2}};
    {\Typing \TEnv {\right \gamma} {\sigma_1 \sim \sigma_2}}
  }
}

\newcommand\KCastCo{
  \ib{\irule[\trule{co-leftc}]
    {\Typing \TEnv \gamma {\kappa_1 \then \tau_1 \sim \kappa_2 \then \tau_2}};
    {\Typing \TEnv {\Cast {\gamma_1} \gamma_2} {\tau_1 \sim \tau_2}}
  }
}


\begin{figure}[ht]
  \centering
  \begin{gather*}
    \fbox{$\Kinding \KEnv \tau \kappa$}\\
    \KReflCo \rsp \KSymCo \rsp \KTransCo \\
    \KForallCo \rsp \KInstCo \\
    \KAppCo \rsp \KLeftCo \rsp \KRightCo \\
  \end{gather*}

    
  \begin{gather*}
    \fbox{$\Typing \TEnv M \tau$}\\
    \TCast
  \end{gather*}

  \caption{Static Semantics of \SFC (extension of \SF)}
  \label{fig:sf-typing}
\end{figure}


\section{\SFR}\label{sec:sfr} % R for roles
Feature of type safe generative types aka newtypes

\begin{figure}[ht]
  \centering
  \begin{syntax}
    \text{Type Vars} &&\alpha,\beta,\gamma \\
    \text{Term Vars} &&x,y          \\
    \text{Kinds}     &&\kappa                  &::= \star \mid \kappa \to \kappa \mid \syntaxhl{\tau \sim \sigma}\\
    \text{Types}     &&\tau,\sigma,\gamma,\nu  &::= \alpha \mid T \mid \syntaxhl{F} \mid \tau \to \tau \mid \Forall {\alpha\co\kappa} \tau\\
    &&                        &\syntaxhl{\mid \sym \Co \mid \comp \nu \Co \mid \Co\At\tau \mid \left \Co \mid \right \Co} \\
    &&                        &\syntaxhl{\mid \leftc \Co \mid \rightc \Co \mid \Cast \Co \Co}\\
    \text{Terms}     &&M,N                     &::= x \mid H \mid \Lam {x\co\tau} M \mid M\App N \mid \TLam{\tau\co\kappa} M \mid M\App \tau
  \end{syntax}
  \caption{Terms and Types of \SFR as an extension of \SFC}
  \label{fig:system-fcr-syntax}
\end{figure}

\begin{figure}[ht]
  \centering
  \begin{gather*}
    \fbox{$\Typing \TEnv M \tau$}
  \end{gather*}
  \caption{Static Semantics of \SFR}
  \label{fig:sfr-typing}
\end{figure}



\section{\SFP}\label{sec:sfp} % P for promotion
We want to promote datatypes to kinds. What does it take?
\begin{figure}[ht]
  \centering
  \begin{syntax}
    \text{Type Vars} &&\alpha,\beta,\gamma \\
    \text{Term Vars} &&x,y          \\
    \text{Kinds}     &&\kappa                  &::= \star \mid \kappa \to \kappa \mid \syntaxhl{\tau \sim \sigma}\\
    \text{Types}     &&\tau,\sigma,\gamma,\nu  &::= \alpha \mid T \mid \syntaxhl{F} \mid \tau \to \tau \mid \Forall {\alpha\co\kappa} \tau\\
    &&                        &\syntaxhl{\mid \sym \Co \mid \comp \nu \Co \mid \Co\At\tau \mid \left \Co \mid \right \Co} \\
    &&                        &\syntaxhl{\mid \leftc \Co \mid \rightc \Co \mid \Cast \Co \Co}\\
    \text{Terms}     &&M,N                     &::= x \mid H \mid \Lam {x\co\tau} M \mid M\App N \mid \TLam{\tau\co\kappa} M \mid M\App \tau
  \end{syntax}
  \caption{Terms and Types of \SFP as an extension of \SFC}
  \label{fig:system-fcp-syntax}
\end{figure}


\begin{figure}[ht]
  \centering
  \begin{gather*}
    \fbox{$\Typing \TEnv M \tau$}
  \end{gather*}
  \caption{Static Semantics of \SFP}
  \label{fig:sfp-typing}
\end{figure}




\section{\SFK}\label{sec:sfk} % K for kind eq
We have type equalities, why not kind equalities?
But we would then have two kinds of equalities: type and kind.
So why not just squish types and kinds together, making it truly impredicative

\begin{figure}[ht]
  \centering
  \begin{syntax}
    \text{Type Vars} &&\alpha,\beta,\gamma \\
    \text{Term Vars} &&x,y          \\
    \text{Kinds}     &&\kappa                  &::= \star \mid \kappa \to \kappa \mid \syntaxhl{\tau \sim \sigma}\\
    \text{Types}     &&\tau,\sigma,\gamma,\nu  &::= \alpha \mid T \mid \syntaxhl{F} \mid \tau \to \tau \mid \Forall {\alpha\co\kappa} \tau\\
    &&                        &\syntaxhl{\mid \sym \Co \mid \comp \nu \Co \mid \Co\At\tau \mid \left \Co \mid \right \Co} \\
    &&                        &\syntaxhl{\mid \leftc \Co \mid \rightc \Co \mid \Cast \Co \Co}\\
    \text{Terms}     &&M,N                     &::= x \mid H \mid \Lam {x\co\tau} M \mid M\App N \mid \TLam{\tau\co\kappa} M \mid M\App \tau
  \end{syntax}
  \caption{Terms and Types of \SFK as an extension of \SFC}
  \label{fig:system-fck-syntax}
\end{figure}


\begin{figure}[ht]
  \centering
  \begin{gather*}
    \fbox{$\Typing \TEnv M \tau$}
  \end{gather*}
  \caption{Static Semantics of \SFK}
  \label{fig:sfk-typing}
\end{figure}


\section{Conclusion and Future work}\label{sec:conclusion}
\begin{figure}[ht]
  \centering
  \begin{tabular}[ht]{c | c | c | c | c | c | c}
    Language & Decidable Type checking & ADTs & GADTs & Open/Closed Type functions & Generative Types & Kind Functions\\
    \hline
    \SF  & & & & &\\
    \SFC & & & & &\\
    \SFP & & & & &\\
    \SFK & & & & &\\
  \end{tabular}
  \caption{Core languages and their Capabilities}
  \label{fig:language-features}
\end{figure}

%%%% Bibliography
\newpage
\bibliography{comp}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% eval: (visual-line-mode 1)
%%% eval: (auto-fill-mode 0)
%%% TeX-master: t
%%% TeX-command-extra-options: "--synctex=1"
%%% End: